# - 동시성 처리 문제 (Concureency)


## 1. 동시성 이슈?
-> 부끄럽게도 들었던 내용인데, 정작 간단한 기술 면접 상황에서 어버버거리면서 답변을 못했던게 사실이다. 멀티스레드 상황에서 하나의 자원을 공유하기 때문에 같은 자원을 두고 경쟁상태가 발생하는 것을 간단히 동시성 이슈라고 할 수 있다. 

여기서 파생되는 동시성과 병렬성(Parallel)의 차이점도 알아둘 필요는 있다.

    동시성 
    1.'동시에 실행되는 것 처럼' 보인다.
    
    2.싱글 코어에서 멀티 스레드를 동작시키기 위한 방식, 여러개의 스레드가 번갈아가면서 실행되는 성질을 말한다.
    
    3.동시성과 멀티스레드는 연관이 없다.

    4.싱글코어에서 멀티스레드를 이용해 동시성을 구현하는 일부 케이스에 대한 내용이다.
    
    5. 멀티코어에서 멀티스레드를 이용해 동시성을 만족할 경우 실제 물리적 시간으로 동시에 실행된다.
<br></br>


    병렬성
    1. '실제로 동시에 실행되는 것'을 의미한다
    2. 멀티코어에서 멀티스레드를 동작시키는 방식
    3. 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다.
    4. 병렬성의 핵심은 물리적인 시간에 동시에 수행되는 것이다. 
    5. 멀티코어가 포커싱이 아님.

---

## 2. 동시성을 제어하는 방법
[Lock 이슈 정리](Lock.md)

1. 암시적 Lock(synchronized)
    - 동시성을 해결하는 가장 간단한 방법은 Lock을 거는 것이다.
    - 문제가 되는 메서드, 변수에 각각 걸 수 있으며 synchronized라는 키워드를 넣는다.
    - 이때 메서드에 lock을 걸게 되면 해당 메서드에 진입하는 스레드는 단 하나로 제한된다.
    - 변수에 lock을 걸 경우 해당 변수는 하나의 스레드만 참조할 수 있다. 이때, 변수에 lock을 걸기 위해서는 해당 변수는 **객채**여야 한다.
    - **int, long** 같은 기본 타입에는 lock을 걸 수 없다.

### 2-1. 메서드 Lock
```java
class Count {
    private int count;
    public synchronized int view() {
        return count++;
    }
}
```

### 2-2. 변수 Lock
```java
class Count {
    private Integer count = 0;
    public int view() {
        synchronized (this.count) {
            return count++;
        }
    }
}
```

## 3. 명시적 Lock

synchronized 키워드 없이 명시적으로 ReentrantLock을 사용하는 방법을 명시적 Lock이라고 한다.